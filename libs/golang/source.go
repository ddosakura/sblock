package sbgo

import (
	"archive/zip"
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/ddosakura/gklang"
)

var (
	w *zip.Writer
)

// Source generater the block
func (p *Plugin) Source(f *os.File, fn func()) {
	// TODO: choose Algorithm

	var (
		buffer bytes.Buffer
		writer io.Writer
	)

	writer = &buffer
	writer = io.MultiWriter(writer, f)
	defer f.Close()
	w = zip.NewWriter(writer)

	fn()

	if err := w.Close(); err != nil {
		gklang.Er(err)
	}

	var comment string
	if p.c.Comment != "" {
		comment = "\n" + commentLines(p.c.Comment)
	}

	// then embed it as a quoted string
	var qb bytes.Buffer
	fmt.Fprintf(&qb, `// Code generated by statik. DO NOT EDIT.
%s
package %s

const (
	Raw = "`, comment, p.c.PKG)
	FprintZipData(&qb, buffer.Bytes())
	fmt.Fprint(&qb, `"
)
`)

	if err := ioutil.WriteFile(f.Name(), qb.Bytes(), 0644); err != nil {
		gklang.Er(err)
	}
}

// Encode is the func for generater
func (p *Plugin) Encode(path, relPath string, fi os.FileInfo, err error) error {
	if err != nil {
		return err
	}
	// Ignore directories and hidden files.
	// No entry is needed for directories in a zip file.
	// Each file is represented with a path, no directory
	// entities are required to build the hierarchy.
	if fi.IsDir() || strings.HasPrefix(fi.Name(), ".") {
		return nil
	}
	b, err := ioutil.ReadFile(path)
	if err != nil {
		return err
	}
	fHeader, err := zip.FileInfoHeader(fi)
	if err != nil {
		return err
	}
	/*
		if *flagNoMtime {
			// Always use the same modification time so that
			// the output is deterministic with respect to the file contents.
			// Do NOT use fHeader.Modified as it only works on go >= 1.10
			fHeader.SetModTime(mtimeDate)
		}
	*/
	fHeader.Name = filepath.ToSlash(relPath)
	/*
		if !*flagNoCompress {
			fHeader.Method = zip.Deflate
		}
	*/
	f, err := w.CreateHeader(fHeader)
	if err != nil {
		return err
	}
	_, err = f.Write(b)
	return err
}
