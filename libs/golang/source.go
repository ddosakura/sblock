package sbgo

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"

	"github.com/ddosakura/gklang"
)

// Source generater the block
func (p *Plugin) Source(f *os.File, fn func()) {
	var (
		buffer bytes.Buffer
		writer io.Writer
	)
	writer = &buffer
	writer = io.MultiWriter(writer, f)
	defer f.Close()

	initAlgorithm(p, writer)
	fn()
	finishAlgorithm(p)

	var comment string
	if p.c.Comment != "" {
		comment = "\n" + commentLines(p.c.Comment)
	}

	// then embed it as a quoted string
	var qb bytes.Buffer
	fmt.Fprintf(&qb, `// Code generated by sblock. DO NOT EDIT.
%s
package %s

const (
	Raw = "`, comment, p.c.PKG)
	FprintZipData(&qb, buffer.Bytes())
	fmt.Fprint(&qb, `"
)
`)

	if err := ioutil.WriteFile(f.Name(), qb.Bytes(), 0644); err != nil {
		gklang.Er(err)
	}
}

// Encode is the func for generater
func (p *Plugin) Encode(path, relPath string, fi os.FileInfo, err error) error {
	if err != nil {
		return err
	}
	// Ignore directories and hidden files.
	// No entry is needed for directories in a zip file.
	// Each file is represented with a path, no directory
	// entities are required to build the hierarchy.
	if fi.IsDir() || strings.HasPrefix(fi.Name(), ".") {
		return nil
	}
	b, err := ioutil.ReadFile(path)
	if err != nil {
		return err
	}

	return encodeAlgorithm(p, relPath, fi, b)
}
